Object.defineProperty(exports, '__esModule', {
  value: true
});

var core = require('@urql/core');

var react = require('react');

var wonka = require('wonka'); // but not to error catastrophically if someone is just playing around


var defaultClient = core.createClient({
  url: '/graphql'
});
var Context = react.createContext(defaultClient);
var Provider = Context.Provider;
var Consumer = Context.Consumer;
Context.displayName = 'UrqlContext';
var hasWarnedAboutDefault = false;

var useClient = () => {
  var client = react.useContext(Context);

  if (process.env.NODE_ENV !== 'production' && client === defaultClient && !hasWarnedAboutDefault) {
    hasWarnedAboutDefault = true;
    console.warn("Default Client: No client has been specified using urql's Provider." + 'This means that urql will be falling back to defaults including making ' + 'requests to `/graphql`.\n' + "If that's not what you want, please create a client and add a Provider.");
  }

  return client;
};

var initialState = {
  fetching: false,
  stale: false,
  error: undefined,
  data: undefined,
  extensions: undefined,
  operation: undefined
};

var isShallowDifferent = (a, b) => {
  if (typeof a != 'object' || typeof b != 'object') return a !== b;

  for (var x in a) {
    if (!(x in b)) return true;
  }

  for (var _x in b) {
    if (a[_x] !== b[_x]) return true;
  }

  return false;
};

var computeNextState = (prevState, result) => {
  var newState = { ...prevState,
    ...result,
    data: result.data !== undefined || result.error ? result.data : prevState.data,
    fetching: !!result.fetching,
    stale: !!result.stale
  };
  return isShallowDifferent(prevState, newState) ? newState : prevState;
};

var hasDepsChanged = (a, b) => {
  for (var i = 0, l = b.length; i < l; i++) {
    if (a[i] !== b[i]) return true;
  }

  return false;
};

function useMutation(query) {
  var isMounted = react.useRef(true);
  var client = useClient();
  var [state, setState] = react.useState(initialState);
  var executeMutation = react.useCallback((variables, context) => {
    setState({ ...initialState,
      fetching: true
    });
    return wonka.toPromise(client.executeMutation(core.createRequest(query, variables), context || {})).then(result => {
      if (isMounted.current) {
        setState({
          fetching: false,
          stale: !!result.stale,
          data: result.data,
          error: result.error,
          extensions: result.extensions,
          operation: result.operation
        });
      }

      return result;
    });
  }, // eslint-disable-next-line react-hooks/exhaustive-deps
  [client, query, setState]);
  react.useEffect(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);
  return [state, executeMutation];
}
/** Creates a request from a query and variables but preserves reference equality if the key isn't changing */


function useRequest(query, variables) {
  var prev = react.useRef(undefined);
  return react.useMemo(() => {
    var request = core.createRequest(query, variables); // We manually ensure reference equality if the key hasn't changed

    if (prev.current !== undefined && prev.current.key === request.key) {
      return prev.current;
    } else {
      prev.current = request;
      return request;
    }
  }, [query, variables]);
}

var getCacheForClient = client => {
  if (!client._react) {
    var reclaim = new Set();
    var map = new Map();

    if (client.operations$
    /* not available in mocks */
    ) {
      wonka.subscribe(operation => {
        if (operation.kind === 'teardown' && reclaim.has(operation.key)) {
          reclaim.delete(operation.key);
          map.delete(operation.key);
        }
      })(client.operations$);
    }

    client._react = {
      get(key) {
        return map.get(key);
      },

      set(key, value) {
        reclaim.delete(key);
        map.set(key, value);
      },

      dispose(key) {
        reclaim.add(key);
      }

    };
  }

  return client._react;
};
/* eslint-disable react-hooks/exhaustive-deps */


var isSuspense = (client, context) => client.suspense && (!context || context.suspense !== false);

function useQuery(args) {
  var client = useClient();
  var cache = getCacheForClient(client);
  var suspense = isSuspense(client, args.context);
  var request = useRequest(args.query, args.variables);
  var source = react.useMemo(() => {
    if (args.pause) return null;
    var source = client.executeQuery(request, {
      requestPolicy: args.requestPolicy,
      ...args.context
    });
    return suspense ? wonka.onPush(result => {
      cache.set(request.key, result);
    })(source) : source;
  }, [cache, client, request, suspense, args.pause, args.requestPolicy, args.context]);
  var getSnapshot = react.useCallback((source, suspense) => {
    if (!source) return {
      fetching: false
    };
    var result = cache.get(request.key);

    if (!result) {
      var resolve;
      var subscription = wonka.subscribe(_result => {
        result = _result;
        if (resolve) resolve(result);
      })(wonka.takeWhile(() => suspense && !resolve || !result)(source));

      if (result == null && suspense) {
        var promise = new Promise(_resolve => {
          resolve = _resolve;
        });
        cache.set(request.key, promise);
        throw promise;
      } else {
        subscription.unsubscribe();
      }
    } else if (suspense && result != null && 'then' in result) {
      throw result;
    }

    return result || {
      fetching: true
    };
  }, [cache, request]);
  var deps = [client, request, args.requestPolicy, args.context, args.pause];
  var [state, setState] = react.useState(() => [source, computeNextState(initialState, getSnapshot(source, suspense)), deps]);
  var currentResult = state[1];

  if (source !== state[0] && hasDepsChanged(state[2], deps)) {
    setState([source, currentResult = computeNextState(state[1], getSnapshot(source, suspense)), deps]);
  }

  react.useEffect(() => {
    var source = state[0];
    var request = state[2][1];
    var hasResult = false;

    var updateResult = result => {
      hasResult = true;
      setState(state => {
        var nextResult = computeNextState(state[1], result);
        return state[1] !== nextResult ? [state[0], nextResult, state[2]] : state;
      });
    };

    if (source) {
      var subscription = wonka.subscribe(updateResult)(wonka.onEnd(() => {
        updateResult({
          fetching: false
        });
      })(source));
      if (!hasResult) updateResult({
        fetching: true
      });
      return () => {
        cache.dispose(request.key);
        subscription.unsubscribe();
      };
    } else {
      updateResult({
        fetching: false
      });
    }
  }, [cache, state[0], state[2][1]]);
  var executeQuery = react.useCallback(opts => {
    var context = {
      requestPolicy: args.requestPolicy,
      ...args.context,
      ...opts
    };
    setState(state => {
      var source = suspense ? wonka.onPush(result => {
        cache.set(request.key, result);
      })(client.executeQuery(request, context)) : client.executeQuery(request, context);
      return [source, state[1], deps];
    });
  }, [client, cache, request, suspense, getSnapshot, args.requestPolicy, args.context]);
  return [currentResult, executeQuery];
}
/* eslint-disable react-hooks/exhaustive-deps */


function useSubscription(args, handler) {
  var client = useClient();
  var request = useRequest(args.query, args.variables);
  var handlerRef = react.useRef(handler);
  handlerRef.current = handler;
  var source = react.useMemo(() => !args.pause ? client.executeSubscription(request, args.context) : null, [client, request, args.pause, args.context]);
  var deps = [client, request, args.context, args.pause];
  var [state, setState] = react.useState(() => [source, { ...initialState,
    fetching: !!source
  }, deps]);
  var currentResult = state[1];

  if (source !== state[0] && hasDepsChanged(state[2], deps)) {
    setState([source, currentResult = computeNextState(state[1], {
      fetching: !!source
    }), deps]);
  }

  react.useEffect(() => {
    var updateResult = result => {
      setState(state => {
        var nextResult = computeNextState(state[1], result);
        if (state[1] === nextResult) return state;

        if (handlerRef.current && state[1].data !== nextResult.data) {
          nextResult.data = handlerRef.current(state[1].data, nextResult.data);
        }

        return [state[0], nextResult, state[2]];
      });
    };

    if (state[0]) {
      return wonka.subscribe(updateResult)(wonka.onEnd(() => {
        updateResult({
          fetching: !!source
        });
      })(state[0])).unsubscribe;
    } else {
      updateResult({
        fetching: false
      });
    }
  }, [state[0]]); // This is the imperative execute function passed to the user

  var executeSubscription = react.useCallback(opts => {
    var source = client.executeSubscription(request, { ...args.context,
      ...opts
    });
    setState(state => [source, state[1], deps]);
  }, [client, args.context, request]);
  return [currentResult, executeSubscription];
}

function Mutation(props) {
  var mutation = useMutation(props.query);
  return props.children({ ...mutation[0],
    executeMutation: mutation[1]
  });
}

function Query(props) {
  var query = useQuery(props);
  return props.children({ ...query[0],
    executeQuery: query[1]
  });
}

function Subscription(props) {
  var subscription = useSubscription(props, props.handler);
  return props.children({ ...subscription[0],
    executeSubscription: subscription[1]
  });
}

exports.Consumer = Consumer;
exports.Context = Context;
exports.Mutation = Mutation;
exports.Provider = Provider;
exports.Query = Query;
exports.Subscription = Subscription;
exports.useClient = useClient;
exports.useMutation = useMutation;
exports.useQuery = useQuery;
exports.useSubscription = useSubscription;
Object.keys(core).forEach(function (k) {
  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () {
      return core[k];
    }
  });
});
//# sourceMappingURL=urql.js.map
