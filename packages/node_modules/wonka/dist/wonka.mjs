var e;

!function(e) {
  e[e.Pull = 0] = "Pull";
  e[e.Close = 1] = "Close";
}(e || (e = {}));

var r;

!function(e) {
  e[e.Start = 0] = "Start";
  e[e.Push = 1] = "Push";
  e[e.End = 0] = "End";
}(r || (r = {}));

var teardownPlaceholder = () => {};

var t = teardownPlaceholder;

function start(e) {
  var t = [ e ];
  t.tag = r.Start;
  return t;
}

function push(e) {
  var t = [ e ];
  t.tag = r.Push;
  return t;
}

var identity = e => e;

function buffer(l) {
  return n => a => {
    var i = [];
    var s = t;
    var f = t;
    var u = !1;
    var o = !1;
    n((t => {
      if (o) {} else if (t === r.End) {
        o = !0;
        f(e.Close);
        if (i.length) {
          a(push(i));
        }
        a(r.End);
      } else if (t.tag === r.Start) {
        s = t[0];
        l((t => {
          if (o) {} else if (t === r.End) {
            o = !0;
            s(e.Close);
            if (i.length) {
              a(push(i));
            }
            a(r.End);
          } else if (t.tag === r.Start) {
            f = t[0];
          } else if (i.length) {
            var l = push(i);
            i = [];
            a(l);
          }
        }));
      } else {
        i.push(t[0]);
        if (!u) {
          u = !0;
          s(e.Pull);
          f(e.Pull);
        } else {
          u = !1;
        }
      }
    }));
    a(start((r => {
      if (r === e.Close && !o) {
        o = !0;
        s(e.Close);
        f(e.Close);
      } else if (!o && !u) {
        u = !0;
        s(e.Pull);
        f(e.Pull);
      }
    })));
  };
}

function concatMap(l) {
  return n => a => {
    var i = [];
    var s = t;
    var f = t;
    var u = !1;
    var o = !1;
    var v = !1;
    var c = !1;
    function applyInnerSource(t) {
      v = !0;
      t((t => {
        if (t === r.End) {
          if (v) {
            v = !1;
            if (i.length) {
              applyInnerSource(l(i.shift()));
            } else if (c) {
              a(r.End);
            } else if (!u) {
              u = !0;
              s(e.Pull);
            }
          }
        } else if (t.tag === r.Start) {
          o = !1;
          (f = t[0])(e.Pull);
        } else if (v) {
          a(t);
          if (o) {
            o = !1;
          } else {
            f(e.Pull);
          }
        }
      }));
    }
    n((e => {
      if (c) {} else if (e === r.End) {
        c = !0;
        if (!v && !i.length) {
          a(r.End);
        }
      } else if (e.tag === r.Start) {
        s = e[0];
      } else {
        u = !1;
        if (v) {
          i.push(e[0]);
        } else {
          applyInnerSource(l(e[0]));
        }
      }
    }));
    a(start((r => {
      if (r === e.Close) {
        if (!c) {
          c = !0;
          s(e.Close);
        }
        if (v) {
          v = !1;
          f(e.Close);
        }
      } else {
        if (!c && !u) {
          u = !0;
          s(e.Pull);
        }
        if (v && !o) {
          o = !0;
          f(e.Pull);
        }
      }
    })));
  };
}

function concatAll(e) {
  return concatMap(identity)(e);
}

function concat(e) {
  return concatAll(l(e));
}

function filter(l) {
  return n => a => {
    var i = t;
    n((t => {
      if (t === r.End) {
        a(r.End);
      } else if (t.tag === r.Start) {
        i = t[0];
        a(t);
      } else if (!l(t[0])) {
        i(e.Pull);
      } else {
        a(t);
      }
    }));
  };
}

function map(e) {
  return t => l => t((t => {
    if (t === r.End || t.tag === r.Start) {
      l(t);
    } else {
      l(push(e(t[0])));
    }
  }));
}

function mergeMap(l) {
  return n => a => {
    var i = [];
    var s = t;
    var f = !1;
    var u = !1;
    n((n => {
      if (u) {} else if (n === r.End) {
        u = !0;
        if (!i.length) {
          a(r.End);
        }
      } else if (n.tag === r.Start) {
        s = n[0];
      } else {
        f = !1;
        !function applyInnerSource(l) {
          var n = t;
          l((t => {
            if (t === r.End) {
              if (i.length) {
                var l = i.indexOf(n);
                if (l > -1) {
                  (i = i.slice()).splice(l, 1);
                }
                if (!i.length) {
                  if (u) {
                    a(r.End);
                  } else if (!f) {
                    f = !0;
                    s(e.Pull);
                  }
                }
              }
            } else if (t.tag === r.Start) {
              i.push(n = t[0]);
              n(e.Pull);
            } else if (i.length) {
              a(t);
              n(e.Pull);
            }
          }));
        }(l(n[0]));
        if (!f) {
          f = !0;
          s(e.Pull);
        }
      }
    }));
    a(start((r => {
      if (r === e.Close) {
        if (!u) {
          u = !0;
          s(e.Close);
        }
        for (var t = 0, l = i, n = i.length; t < n; t++) {
          l[t](e.Close);
        }
        i.length = 0;
      } else {
        if (!u && !f) {
          f = !0;
          s(e.Pull);
        } else {
          f = !1;
        }
        for (var a = 0, o = i, v = i.length; a < v; a++) {
          o[a](e.Pull);
        }
      }
    })));
  };
}

function mergeAll(e) {
  return mergeMap(identity)(e);
}

function merge(e) {
  return mergeAll(l(e));
}

function onEnd(t) {
  return l => n => {
    var a = !1;
    l((l => {
      if (a) {} else if (l === r.End) {
        a = !0;
        n(r.End);
        t();
      } else if (l.tag === r.Start) {
        var i = l[0];
        n(start((r => {
          if (r === e.Close) {
            a = !0;
            i(e.Close);
            t();
          } else {
            i(r);
          }
        })));
      } else {
        n(l);
      }
    }));
  };
}

function onPush(t) {
  return l => n => {
    var a = !1;
    l((l => {
      if (a) {} else if (l === r.End) {
        a = !0;
        n(r.End);
      } else if (l.tag === r.Start) {
        var i = l[0];
        n(start((r => {
          if (r === e.Close) {
            a = !0;
          }
          i(r);
        })));
      } else {
        t(l[0]);
        n(l);
      }
    }));
  };
}

function onStart(e) {
  return t => l => t((t => {
    if (t === r.End) {
      l(r.End);
    } else if (t.tag === r.Start) {
      l(t);
      e();
    } else {
      l(t);
    }
  }));
}

function sample(l) {
  return n => a => {
    var i = t;
    var s = t;
    var f;
    var u = !1;
    var o = !1;
    n((t => {
      if (o) {} else if (t === r.End) {
        o = !0;
        s(e.Close);
        a(r.End);
      } else if (t.tag === r.Start) {
        i = t[0];
      } else {
        f = t[0];
        if (!u) {
          u = !0;
          s(e.Pull);
          i(e.Pull);
        } else {
          u = !1;
        }
      }
    }));
    l((t => {
      if (o) {} else if (t === r.End) {
        o = !0;
        i(e.Close);
        a(r.End);
      } else if (t.tag === r.Start) {
        s = t[0];
      } else if (void 0 !== f) {
        var l = push(f);
        f = void 0;
        a(l);
      }
    }));
    a(start((r => {
      if (r === e.Close && !o) {
        o = !0;
        i(e.Close);
        s(e.Close);
      } else if (!o && !u) {
        u = !0;
        i(e.Pull);
        s(e.Pull);
      }
    })));
  };
}

function scan(e, t) {
  return l => n => {
    var a = t;
    l((t => {
      if (t === r.End) {
        n(r.End);
      } else if (t.tag === r.Start) {
        n(t);
      } else {
        n(push(a = e(a, t[0])));
      }
    }));
  };
}

function share(l) {
  var n = [];
  var a = t;
  var i = !1;
  return t => {
    n.push(t);
    if (1 === n.length) {
      l((e => {
        if (e === r.End) {
          for (var t = 0, l = n, s = n.length; t < s; t++) {
            l[t](r.End);
          }
          n.length = 0;
        } else if (e.tag === r.Start) {
          a = e[0];
        } else {
          i = !1;
          for (var f = 0, u = n, o = n.length; f < o; f++) {
            u[f](e);
          }
        }
      }));
    }
    t(start((r => {
      if (r === e.Close) {
        var l = n.indexOf(t);
        if (l > -1) {
          (n = n.slice()).splice(l, 1);
        }
        if (!n.length) {
          a(e.Close);
        }
      } else if (!i) {
        i = !0;
        a(e.Pull);
      }
    })));
  };
}

function skip(l) {
  return n => a => {
    var i = t;
    var s = l;
    n((t => {
      if (t === r.End) {
        a(r.End);
      } else if (t.tag === r.Start) {
        i = t[0];
        a(t);
      } else if (s-- > 0) {
        i(e.Pull);
      } else {
        a(t);
      }
    }));
  };
}

function skipUntil(l) {
  return n => a => {
    var i = t;
    var s = t;
    var f = !0;
    var u = !1;
    var o = !1;
    n((t => {
      if (o) {} else if (t === r.End) {
        o = !0;
        if (f) {
          s(e.Close);
        }
        a(r.End);
      } else if (t.tag === r.Start) {
        i = t[0];
        l((t => {
          if (t === r.End) {
            if (f) {
              o = !0;
              i(e.Close);
            }
          } else if (t.tag === r.Start) {
            (s = t[0])(e.Pull);
          } else {
            f = !1;
            s(e.Close);
          }
        }));
      } else if (!f) {
        u = !1;
        a(t);
      } else if (!u) {
        u = !0;
        i(e.Pull);
        s(e.Pull);
      } else {
        u = !1;
      }
    }));
    a(start((r => {
      if (r === e.Close && !o) {
        o = !0;
        i(e.Close);
        if (f) {
          s(e.Close);
        }
      } else if (!o && !u) {
        u = !0;
        if (f) {
          s(e.Pull);
        }
        i(e.Pull);
      }
    })));
  };
}

function skipWhile(l) {
  return n => a => {
    var i = t;
    var s = !0;
    n((t => {
      if (t === r.End) {
        a(r.End);
      } else if (t.tag === r.Start) {
        i = t[0];
        a(t);
      } else if (s) {
        if (l(t[0])) {
          i(e.Pull);
        } else {
          s = !1;
          a(t);
        }
      } else {
        a(t);
      }
    }));
  };
}

function switchMap(l) {
  return n => a => {
    var i = t;
    var s = t;
    var f = !1;
    var u = !1;
    var o = !1;
    var v = !1;
    n((n => {
      if (v) {} else if (n === r.End) {
        v = !0;
        if (!o) {
          a(r.End);
        }
      } else if (n.tag === r.Start) {
        i = n[0];
      } else {
        if (o) {
          s(e.Close);
          s = t;
        }
        if (!f) {
          f = !0;
          i(e.Pull);
        } else {
          f = !1;
        }
        !function applyInnerSource(t) {
          o = !0;
          t((t => {
            if (!o) {} else if (t === r.End) {
              o = !1;
              if (v) {
                a(r.End);
              } else if (!f) {
                f = !0;
                i(e.Pull);
              }
            } else if (t.tag === r.Start) {
              u = !1;
              (s = t[0])(e.Pull);
            } else {
              a(t);
              if (!u) {
                s(e.Pull);
              } else {
                u = !1;
              }
            }
          }));
        }(l(n[0]));
      }
    }));
    a(start((r => {
      if (r === e.Close) {
        if (!v) {
          v = !0;
          i(e.Close);
        }
        if (o) {
          o = !1;
          s(e.Close);
        }
      } else {
        if (!v && !f) {
          f = !0;
          i(e.Pull);
        }
        if (o && !u) {
          u = !0;
          s(e.Pull);
        }
      }
    })));
  };
}

function switchAll(e) {
  return switchMap(identity)(e);
}

function take(l) {
  return n => a => {
    var i = t;
    var s = !1;
    var f = 0;
    n((t => {
      if (s) {} else if (t === r.End) {
        s = !0;
        a(r.End);
      } else if (t.tag === r.Start) {
        if (l <= 0) {
          s = !0;
          a(r.End);
          t[0](e.Close);
        } else {
          i = t[0];
        }
      } else if (f++ < l) {
        a(t);
        if (!s && f >= l) {
          s = !0;
          a(r.End);
          i(e.Close);
        }
      } else {
        a(t);
      }
    }));
    a(start((r => {
      if (r === e.Close && !s) {
        s = !0;
        i(e.Close);
      } else if (r === e.Pull && !s && f < l) {
        i(e.Pull);
      }
    })));
  };
}

function takeLast(n) {
  return a => i => {
    var s = [];
    var f = t;
    a((t => {
      if (t === r.End) {
        l(s)(i);
      } else if (t.tag === r.Start) {
        if (n <= 0) {
          t[0](e.Close);
          l(s)(i);
        } else {
          (f = t[0])(e.Pull);
        }
      } else {
        if (s.length >= n && n) {
          s.shift();
        }
        s.push(t[0]);
        f(e.Pull);
      }
    }));
  };
}

function takeUntil(l) {
  return n => a => {
    var i = t;
    var s = t;
    var f = !1;
    n((t => {
      if (f) {} else if (t === r.End) {
        f = !0;
        s(e.Close);
        a(r.End);
      } else if (t.tag === r.Start) {
        i = t[0];
        l((t => {
          if (t === r.End) {} else if (t.tag === r.Start) {
            (s = t[0])(e.Pull);
          } else {
            f = !0;
            s(e.Close);
            i(e.Close);
            a(r.End);
          }
        }));
      } else {
        a(t);
      }
    }));
    a(start((r => {
      if (r === e.Close && !f) {
        f = !0;
        i(e.Close);
        s(e.Close);
      } else if (!f) {
        i(e.Pull);
      }
    })));
  };
}

function takeWhile(l) {
  return n => a => {
    var i = t;
    var s = !1;
    n((t => {
      if (s) {} else if (t === r.End) {
        s = !0;
        a(r.End);
      } else if (t.tag === r.Start) {
        i = t[0];
        a(t);
      } else if (!l(t[0])) {
        s = !0;
        a(r.End);
        i(e.Close);
      } else {
        a(t);
      }
    }));
  };
}

function debounce(t) {
  return l => n => {
    var a;
    var i = !1;
    var s = !1;
    l((l => {
      if (s) {} else if (l === r.End) {
        s = !0;
        if (a) {
          i = !0;
        } else {
          n(r.End);
        }
      } else if (l.tag === r.Start) {
        var f = l[0];
        n(start((r => {
          if (r === e.Close && !s) {
            s = !0;
            i = !1;
            if (a) {
              clearTimeout(a);
            }
            f(e.Close);
          } else if (!s) {
            f(e.Pull);
          }
        })));
      } else {
        if (a) {
          clearTimeout(a);
        }
        a = setTimeout((() => {
          a = void 0;
          n(l);
          if (i) {
            n(r.End);
          }
        }), t(l[0]));
      }
    }));
  };
}

function delay(e) {
  return t => l => {
    var n = 0;
    t((t => {
      if (t !== r.End && t.tag === r.Start) {
        l(t);
      } else {
        n++;
        setTimeout((() => {
          if (n) {
            n--;
            l(t);
          }
        }), e);
      }
    }));
  };
}

function throttle(t) {
  return l => n => {
    var a = !1;
    var i;
    l((l => {
      if (l === r.End) {
        if (i) {
          clearTimeout(i);
        }
        n(r.End);
      } else if (l.tag === r.Start) {
        var s = l[0];
        n(start((r => {
          if (r === e.Close) {
            if (i) {
              clearTimeout(i);
            }
            s(e.Close);
          } else {
            s(e.Pull);
          }
        })));
      } else if (!a) {
        a = !0;
        if (i) {
          clearTimeout(i);
        }
        i = setTimeout((() => {
          i = void 0;
          a = !1;
        }), t(l[0]));
        n(l);
      }
    }));
  };
}

function lazy(e) {
  return r => e()(r);
}

function fromAsyncIterable(t) {
  return l => {
    var n = t[Symbol.asyncIterator]();
    var a = !1;
    var i = !1;
    var s = !1;
    var f;
    l(start((async t => {
      if (t === e.Close) {
        a = !0;
        if (n.return) {
          n.return();
        }
      } else if (i) {
        s = !0;
      } else {
        for (s = i = !0; s && !a; ) {
          if ((f = await n.next()).done) {
            a = !0;
            if (n.return) {
              await n.return();
            }
            l(r.End);
          } else {
            try {
              s = !1;
              l(push(f.value));
            } catch (e) {
              if (n.throw) {
                if (a = !!(await n.throw(e)).done) {
                  l(r.End);
                }
              } else {
                throw e;
              }
            }
          }
        }
        i = !1;
      }
    })));
  };
}

function fromIterable(t) {
  if (t[Symbol.asyncIterator]) {
    return fromAsyncIterable(t);
  }
  return l => {
    var n = t[Symbol.iterator]();
    var a = !1;
    var i = !1;
    var s = !1;
    var f;
    l(start((t => {
      if (t === e.Close) {
        a = !0;
        if (n.return) {
          n.return();
        }
      } else if (i) {
        s = !0;
      } else {
        for (s = i = !0; s && !a; ) {
          if ((f = n.next()).done) {
            a = !0;
            if (n.return) {
              n.return();
            }
            l(r.End);
          } else {
            try {
              s = !1;
              l(push(f.value));
            } catch (e) {
              if (n.throw) {
                if (a = !!n.throw(e).done) {
                  l(r.End);
                }
              } else {
                throw e;
              }
            }
          }
        }
        i = !1;
      }
    })));
  };
}

var l = fromIterable;

function fromValue(t) {
  return l => {
    var n = !1;
    l(start((a => {
      if (a === e.Close) {
        n = !0;
      } else if (!n) {
        n = !0;
        l(push(t));
        l(r.End);
      }
    })));
  };
}

function make(t) {
  return l => {
    var n = !1;
    var a = t({
      next(e) {
        if (!n) {
          l(push(e));
        }
      },
      complete() {
        if (!n) {
          n = !0;
          l(r.End);
        }
      }
    });
    l(start((r => {
      if (r === e.Close && !n) {
        n = !0;
        a();
      }
    })));
  };
}

function makeSubject() {
  var e;
  var r;
  return {
    source: share(make((t => {
      e = t.next;
      r = t.complete;
      return teardownPlaceholder;
    }))),
    next(r) {
      if (e) {
        e(r);
      }
    },
    complete() {
      if (r) {
        r();
      }
    }
  };
}

var empty = t => {
  var l = !1;
  t(start((n => {
    if (n === e.Close) {
      l = !0;
    } else if (!l) {
      l = !0;
      t(r.End);
    }
  })));
};

var never = e => {
  e(start(t));
};

function interval(e) {
  return make((r => {
    var t = 0;
    var l = setInterval((() => r.next(t++)), e);
    return () => clearInterval(l);
  }));
}

function fromDomEvent(e, r) {
  return make((t => {
    e.addEventListener(r, t.next);
    return () => e.removeEventListener(r, t.next);
  }));
}

function fromPromise(e) {
  return make((r => {
    e.then((e => {
      Promise.resolve(e).then((() => {
        r.next(e);
        r.complete();
      }));
    }));
    return teardownPlaceholder;
  }));
}

function subscribe(l) {
  return n => {
    var a = t;
    var i = !1;
    n((t => {
      if (t === r.End) {
        i = !0;
      } else if (t.tag === r.Start) {
        (a = t[0])(e.Pull);
      } else if (!i) {
        l(t[0]);
        a(e.Pull);
      }
    }));
    return {
      unsubscribe() {
        if (!i) {
          i = !0;
          a(e.Close);
        }
      }
    };
  };
}

function forEach(e) {
  return r => {
    subscribe(e)(r);
  };
}

function publish(e) {
  subscribe((e => {}))(e);
}

var n = {
  done: !0
};

var toAsyncIterable = l => ({
  [Symbol.asyncIterator]() {
    var a = [];
    var i = !1;
    var s = t;
    var f;
    l((t => {
      if (i) {} else if (t === r.End) {
        if (f) {
          f = f(n);
        }
        i = !0;
      } else if (t.tag === r.Start) {
        (s = t[0])(e.Pull);
      } else if (f) {
        f = f({
          value: t[0],
          done: !1
        });
      } else {
        a.push(t[0]);
      }
    }));
    return {
      async next() {
        if (i && !a.length) {
          return n;
        } else if (!i && a.length <= 1) {
          s(e.Pull);
        }
        return a.length ? {
          value: a.shift(),
          done: !1
        } : new Promise((e => f = e));
      },
      async return() {
        if (!i) {
          f = s(e.Close);
        }
        i = !0;
        return n;
      }
    };
  }
});

function toArray(l) {
  var n = [];
  var a = t;
  var i = !1;
  l((t => {
    if (t === r.End) {
      i = !0;
    } else if (t.tag === r.Start) {
      (a = t[0])(e.Pull);
    } else {
      n.push(t[0]);
      a(e.Pull);
    }
  }));
  if (!i) {
    a(e.Close);
  }
  return n;
}

function toPromise(l) {
  return new Promise((n => {
    var a = t;
    var i;
    l((t => {
      if (t === r.End) {
        Promise.resolve(i).then(n);
      } else if (t.tag === r.Start) {
        (a = t[0])(e.Pull);
      } else {
        i = t[0];
        a(e.Pull);
      }
    }));
  }));
}

function zip(l) {
  var n = Object.keys(l).length;
  return a => {
    var i = new Set;
    var s = Array.isArray(l) ? new Array(n).fill(t) : {};
    var f = Array.isArray(l) ? new Array(n) : {};
    var u = !1;
    var o = !1;
    var v = !1;
    var c = 0;
    var loop = function(d) {
      l[d]((h => {
        if (h === r.End) {
          if (c >= n - 1) {
            v = !0;
            a(r.End);
          } else {
            c++;
          }
        } else if (h.tag === r.Start) {
          s[d] = h[0];
        } else if (!v) {
          f[d] = h[0];
          i.add(d);
          if (!u && i.size < n) {
            if (!o) {
              for (var E in l) {
                if (!i.has(E)) {
                  (s[E] || t)(e.Pull);
                }
              }
            } else {
              o = !1;
            }
          } else {
            u = !0;
            o = !1;
            a(push(Array.isArray(f) ? f.slice() : {
              ...f
            }));
          }
        }
      }));
    };
    for (var d in l) {
      loop(d);
    }
    a(start((r => {
      if (v) {} else if (r === e.Close) {
        v = !0;
        for (var t in s) {
          s[t](e.Close);
        }
      } else if (!o) {
        o = !0;
        for (var l in s) {
          s[l](e.Pull);
        }
      }
    })));
  };
}

function combine(...e) {
  return zip(e);
}

var observableSymbol = () => Symbol.observable || "@@observable";

function fromObservable(t) {
  return l => {
    var n = (t[observableSymbol()] ? t[observableSymbol()]() : t).subscribe({
      next(e) {
        l(push(e));
      },
      complete() {
        l(r.End);
      },
      error(e) {
        throw e;
      }
    });
    l(start((r => {
      if (r === e.Close) {
        n.unsubscribe();
      }
    })));
  };
}

function toObservable(l) {
  return {
    subscribe(n, a, i) {
      var s = "object" == typeof n ? n : {
        next: n,
        error: a,
        complete: i
      };
      var f = t;
      var u = !1;
      l((t => {
        if (u) {} else if (t === r.End) {
          u = !0;
          if (s.complete) {
            s.complete();
          }
        } else if (t.tag === r.Start) {
          (f = t[0])(e.Pull);
        } else {
          s.next(t[0]);
          f(e.Pull);
        }
      }));
      var o = {
        closed: !1,
        unsubscribe() {
          o.closed = !0;
          u = !0;
          f(e.Close);
        }
      };
      return o;
    },
    [observableSymbol()]() {
      return this;
    }
  };
}

function fromCallbag(e) {
  return t => {
    e(0, ((e, l) => {
      if (0 === e) {
        t(start((e => {
          l(e + 1);
        })));
      } else if (1 === e) {
        t(push(l));
      } else {
        t(r.End);
      }
    }));
  };
}

function toCallbag(e) {
  return (t, l) => {
    if (0 === t) {
      e((e => {
        if (e === r.End) {
          l(2);
        } else if (e.tag === r.Start) {
          l(0, (r => {
            if (r < 3) {
              e[0](r - 1);
            }
          }));
        } else {
          l(1, e[0]);
        }
      }));
    }
  };
}

var pipe = (...e) => {
  var r = e[0];
  for (var t = 1, l = e.length; t < l; t++) {
    r = e[t](r);
  }
  return r;
};

export { buffer, combine, concat, concatAll, concatMap, debounce, delay, empty, filter, mergeAll as flatten, forEach, l as fromArray, fromAsyncIterable, fromCallbag, fromDomEvent, fromIterable, fromObservable, fromPromise, fromValue, interval, lazy, make, makeSubject, map, merge, mergeAll, mergeMap, never, onEnd, onPush, onStart, pipe, publish, sample, scan, share, skip, skipUntil, skipWhile, subscribe, switchAll, switchMap, take, takeLast, takeUntil, takeWhile, onPush as tap, throttle, toArray, toAsyncIterable, toCallbag, toObservable, toPromise, zip };
//# sourceMappingURL=wonka.mjs.map
