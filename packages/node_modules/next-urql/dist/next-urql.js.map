{"version":3,"file":"next-urql.js","sources":["../src/init-urql-client.ts","../src/with-urql-client.ts"],"sourcesContent":["import { Client, ClientOptions, createClient } from '@urql/core';\n\nlet urqlClient: Client | null = null;\n\nexport function resetClient() {\n  urqlClient = null;\n}\n\nexport function initUrqlClient(\n  clientOptions: ClientOptions,\n  canEnableSuspense: boolean\n): Client | null {\n  // Create a new Client for every server-side rendered request.\n  // This ensures we reset the state for each rendered page.\n  // If there is an exising client instance on the client-side, use it.\n  const isServer = typeof window === 'undefined';\n  if (isServer || !urqlClient) {\n    urqlClient = createClient({\n      ...clientOptions,\n      suspense: canEnableSuspense && (isServer || clientOptions.suspense),\n    });\n    // Serialize the urqlClient to null on the client-side.\n    // This ensures we don't share client and server instances of the urqlClient.\n    (urqlClient as any).toJSON = () => null;\n  }\n\n  // Return both the Client instance and the ssrCache.\n  return urqlClient;\n}\n","import {\n  createElement,\n  useCallback,\n  useReducer,\n  useMemo,\n  ReactNode,\n  ReactElement,\n} from 'react';\nimport ssrPrepass from 'react-ssr-prepass';\nimport { NextComponentType, NextPage, NextPageContext } from 'next';\nimport NextApp, { AppContext } from 'next/app';\n\nimport {\n  Provider,\n  ssrExchange,\n  dedupExchange,\n  cacheExchange,\n  fetchExchange,\n} from 'urql';\n\nimport { initUrqlClient, resetClient } from './init-urql-client';\n\nimport {\n  NextUrqlClientConfig,\n  NextUrqlContext,\n  WithUrqlProps,\n  WithUrqlClientOptions,\n  SSRExchange,\n} from './types';\n\nlet ssr: SSRExchange;\ntype NextPageWithLayout = NextPage & {\n  getLayout?: (page: ReactElement) => ReactNode;\n};\n\nexport function withUrqlClient(\n  getClientConfig: NextUrqlClientConfig,\n  options?: WithUrqlClientOptions\n) {\n  if (!options) options = {};\n\n  return <C extends NextPage<any> | typeof NextApp>(\n    AppOrPage: C\n  ): NextComponentType<NextUrqlContext, {}, WithUrqlProps> => {\n    const shouldEnableSuspense = Boolean(\n      (AppOrPage.getInitialProps || options!.ssr) && !options!.neverSuspend\n    );\n\n    const WithUrql = ({\n      pageProps,\n      urqlClient,\n      urqlState,\n      ...rest\n    }: WithUrqlProps) => {\n      const [version, forceUpdate] = useReducer(prev => prev + 1, 0);\n      const urqlServerState = (pageProps && pageProps.urqlState) || urqlState;\n\n      const client = useMemo(() => {\n        if (urqlClient && !version) {\n          return urqlClient;\n        }\n\n        if (!ssr || typeof window === 'undefined') {\n          // We want to force the cache to hydrate, we do this by setting the isClient flag to true\n          ssr = ssrExchange({\n            initialState: urqlServerState,\n            isClient: true,\n            staleWhileRevalidate:\n              typeof window !== 'undefined'\n                ? options!.staleWhileRevalidate\n                : undefined,\n          });\n        } else if (!version) {\n          ssr.restoreData(urqlServerState);\n        }\n\n        const clientConfig = getClientConfig(ssr);\n        if (!clientConfig.exchanges) {\n          // When the user does not provide exchanges we make the default assumption.\n          clientConfig.exchanges = [\n            dedupExchange,\n            cacheExchange,\n            ssr,\n            fetchExchange,\n          ];\n        }\n\n        return initUrqlClient(clientConfig, shouldEnableSuspense)!;\n      }, [urqlClient, urqlServerState, version]);\n\n      const resetUrqlClient = useCallback(() => {\n        resetClient();\n        ssr = ssrExchange({ initialState: undefined });\n        forceUpdate();\n      }, []);\n\n      return createElement(\n        Provider,\n        { value: client },\n        createElement(AppOrPage, {\n          ...rest,\n          pageProps,\n          urqlClient: client,\n          resetUrqlClient,\n        })\n      );\n    };\n\n    // Set the displayName to indicate use of withUrqlClient.\n    const displayName =\n      (AppOrPage as any).displayName || AppOrPage.name || 'Component';\n    WithUrql.displayName = `withUrqlClient(${displayName})`;\n\n    if ((AppOrPage as NextPageWithLayout).getLayout) {\n      WithUrql.getLayout = (AppOrPage as NextPageWithLayout).getLayout;\n    }\n\n    if (AppOrPage.getInitialProps || options!.ssr) {\n      WithUrql.getInitialProps = async (appOrPageCtx: NextUrqlContext) => {\n        const AppTree = appOrPageCtx.AppTree!;\n\n        // Determine if we are wrapping an App component or a Page component.\n        const isApp = !!(appOrPageCtx as AppContext).Component;\n        const ctx = isApp\n          ? (appOrPageCtx as AppContext).ctx\n          : (appOrPageCtx as NextPageContext);\n\n        const ssrCache = ssrExchange({ initialState: undefined });\n        const clientConfig = getClientConfig(ssrCache, ctx);\n        if (!clientConfig.exchanges) {\n          // When the user does not provide exchanges we make the default assumption.\n          clientConfig.exchanges = [\n            dedupExchange,\n            cacheExchange,\n            ssrCache,\n            fetchExchange,\n          ];\n        }\n\n        const urqlClient = initUrqlClient(clientConfig, !options!.neverSuspend);\n\n        if (urqlClient) {\n          (ctx as NextUrqlContext).urqlClient = urqlClient;\n        }\n\n        // Run the wrapped component's getInitialProps function.\n        let pageProps = {} as any;\n        if (AppOrPage.getInitialProps) {\n          pageProps = await AppOrPage.getInitialProps(appOrPageCtx as any);\n          if (ctx.res && (ctx.res.writableEnded || ctx.res.finished)) {\n            return { ...pageProps, urqlClient };\n          }\n        }\n\n        // Check the window object to determine whether or not we are on the server.\n        // getInitialProps runs on the server for initial render, and on the client for navigation.\n        // We only want to run the prepass step on the server.\n        if (typeof window !== 'undefined') {\n          return { ...pageProps, urqlClient };\n        }\n\n        const props = { ...pageProps, urqlClient };\n        const appTreeProps = isApp\n          ? { pageProps: {}, ...props }\n          : { pageProps: props };\n\n        // Run the prepass step on AppTree. This will run all urql queries on the server.\n        if (!options!.neverSuspend) {\n          await ssrPrepass(createElement(AppTree, appTreeProps));\n        }\n\n        return {\n          ...pageProps,\n          urqlState: ssrCache ? ssrCache.extractData() : undefined,\n          urqlClient,\n        };\n      };\n    }\n\n    return WithUrql;\n  };\n}\n"],"names":["urqlClient","resetClient","initUrqlClient","clientOptions","canEnableSuspense","isServer","window","toJSON","ssr","withUrqlClient","getClientConfig","options","shouldEnableSuspense","Boolean","AppOrPage","getInitialProps","neverSuspend","WithUrql","pageProps","urqlState","rest","version","forceUpdate","useReducer","prev","client","useMemo","initialState","urqlServerState","isClient","staleWhileRevalidate","undefined","restoreData","clientConfig","exchanges","resetUrqlClient","useCallback","createElement","Provider","value","displayName","getLayout","appOrPageCtx","AppTree","isApp","Component","ctx","res","writableEnded","finished","props","ssrCache","extractData"],"mappings":"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"}