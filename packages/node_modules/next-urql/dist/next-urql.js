Object.defineProperty(exports, '__esModule', {
  value: true
});
var react = require('react');
var ssrPrepass = require('react-ssr-prepass');
var urql = require('urql');
var core = require('@urql/core');
var urqlClient = null;
function resetClient() {
  urqlClient = null;
}
function initUrqlClient(clientOptions, canEnableSuspense) {
  // Create a new Client for every server-side rendered request.
  // This ensures we reset the state for each rendered page.
  // If there is an exising client instance on the client-side, use it.
  var isServer = typeof window === 'undefined';
  if (isServer || !urqlClient) {
    urqlClient = core.createClient({
      ...clientOptions,
      suspense: canEnableSuspense && (isServer || clientOptions.suspense)
    });
    // Serialize the urqlClient to null on the client-side.
    // This ensures we don't share client and server instances of the urqlClient.
    urqlClient.toJSON = () => null;
  }
  // Return both the Client instance and the ssrCache.
  return urqlClient;
}
var ssr;
function withUrqlClient(getClientConfig, options) {
  if (!options) options = {};
  return AppOrPage => {
    var shouldEnableSuspense = Boolean((AppOrPage.getInitialProps || options.ssr) && !options.neverSuspend);
    var WithUrql = ({
      pageProps,
      urqlClient,
      urqlState,
      ...rest
    }) => {
      var [version, forceUpdate] = react.useReducer(prev => prev + 1, 0);
      var urqlServerState = pageProps && pageProps.urqlState || urqlState;
      var client = react.useMemo(() => {
        if (urqlClient && !version) {
          return urqlClient;
        }
        if (!ssr || typeof window === 'undefined') {
          // We want to force the cache to hydrate, we do this by setting the isClient flag to true
          ssr = urql.ssrExchange({
            initialState: urqlServerState,
            isClient: true,
            staleWhileRevalidate: typeof window !== 'undefined' ? options.staleWhileRevalidate : undefined
          });
        } else if (!version) {
          ssr.restoreData(urqlServerState);
        }
        var clientConfig = getClientConfig(ssr);
        if (!clientConfig.exchanges) {
          // When the user does not provide exchanges we make the default assumption.
          clientConfig.exchanges = [urql.dedupExchange, urql.cacheExchange, ssr, urql.fetchExchange];
        }
        return initUrqlClient(clientConfig, shouldEnableSuspense);
      }, [urqlClient, urqlServerState, version]);
      var resetUrqlClient = react.useCallback(() => {
        resetClient();
        ssr = urql.ssrExchange({
          initialState: undefined
        });
        forceUpdate();
      }, []);
      return react.createElement(urql.Provider, {
        value: client
      }, react.createElement(AppOrPage, {
        ...rest,
        pageProps,
        urqlClient: client,
        resetUrqlClient
      }));
    };
    // Set the displayName to indicate use of withUrqlClient.
    var displayName = AppOrPage.displayName || AppOrPage.name || 'Component';
    WithUrql.displayName = `withUrqlClient(${displayName})`;
    if (AppOrPage.getLayout) {
      WithUrql.getLayout = AppOrPage.getLayout;
    }
    if (AppOrPage.getInitialProps || options.ssr) {
      WithUrql.getInitialProps = async appOrPageCtx => {
        var AppTree = appOrPageCtx.AppTree;
        // Determine if we are wrapping an App component or a Page component.
        var isApp = !!appOrPageCtx.Component;
        var ctx = isApp ? appOrPageCtx.ctx : appOrPageCtx;
        var ssrCache = urql.ssrExchange({
          initialState: undefined
        });
        var clientConfig = getClientConfig(ssrCache, ctx);
        if (!clientConfig.exchanges) {
          // When the user does not provide exchanges we make the default assumption.
          clientConfig.exchanges = [urql.dedupExchange, urql.cacheExchange, ssrCache, urql.fetchExchange];
        }
        var urqlClient = initUrqlClient(clientConfig, !options.neverSuspend);
        if (urqlClient) {
          ctx.urqlClient = urqlClient;
        }
        // Run the wrapped component's getInitialProps function.
        var pageProps = {};
        if (AppOrPage.getInitialProps) {
          pageProps = await AppOrPage.getInitialProps(appOrPageCtx);
          if (ctx.res && (ctx.res.writableEnded || ctx.res.finished)) {
            return {
              ...pageProps,
              urqlClient
            };
          }
        }
        // Check the window object to determine whether or not we are on the server.
        // getInitialProps runs on the server for initial render, and on the client for navigation.
        // We only want to run the prepass step on the server.
        if (typeof window !== 'undefined') {
          return {
            ...pageProps,
            urqlClient
          };
        }
        var props = {
          ...pageProps,
          urqlClient
        };
        var appTreeProps = isApp ? {
          pageProps: {},
          ...props
        } : {
          pageProps: props
        };
        // Run the prepass step on AppTree. This will run all urql queries on the server.
        if (!options.neverSuspend) {
          await ssrPrepass(react.createElement(AppTree, appTreeProps));
        }
        return {
          ...pageProps,
          urqlState: ssrCache ? ssrCache.extractData() : undefined,
          urqlClient
        };
      };
    }
    return WithUrql;
  };
}
exports.initUrqlClient = initUrqlClient;
exports.withUrqlClient = withUrqlClient;
//# sourceMappingURL=next-urql.js.map
