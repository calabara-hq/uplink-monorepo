import { Address, Hex } from "viem";
import { DeferredTokenIntentWithSignature } from "@tx-kit/sdk"
import { IChannel, IUpgradePath } from "@tx-kit/sdk/subgraph";

export type ContractID = `0x${string}-${number}`;

export const concatContractID = ({ chainId, contractAddress }: { chainId: number, contractAddress: string }) => {
    return `${contractAddress}-${chainId}` as ContractID;
}

export const splitContractID = (contractID: string) => {
    const [contractAddress, chainId] = contractID.split("-");
    return { chainId: parseInt(chainId), contractAddress };
}

export type ChannelUpgradePath = IUpgradePath

export type Channel = IChannel & {
    chainId: number;
};

// internal type to match metadata standards onchain
export type UploadToIpfsTokenMetadata = {
    name: string;
    description: string;
    image: string;
    type: "uplink-v2";
    content: {
        mime: string;
        uri: string;
    }
    animation_uri?: string;
}

// type generated by subgraph / parsers for clients
export type TokenMetadata = {
    id: string;
    name: string;
    description: string;
    image: string;
    animation: string;
    type: "uplink-v1" | "uplink-v2";
}

export type ChannelTokenV1 = {
    id: string;
    chainId: number;
    contractAddress: Address;
    channelAddress: Address;
    maxSupply: string;
    totalMinted: string;
    author: Address;
    publicSalePrice: string;
    publicSaleStart: string;
    publicSaleEnd: string;

    name: string;
    description: string;
    animationURI: string;
    imageURI: string;

    metadata: TokenMetadata;
}

export type ChannelToken = {
    id: string;
    channelAddress: Address;
    tokenId: string;
    uri: string;
    author: Address;
    sponsor: Address;
    totalMinted: string;
    maxSupply: string;
    createdAt: string;
    blockNumber: string;
    blockTimestamp: string;
    metadata: TokenMetadata;
}


export type ChannelTokenIntent = {
    id: string;
    spaceId: number;
    channelId: number;
    channelAddress: Address;
    tokenIntent: string
    deadline: string;
    createdAt: string;
    metadata: TokenMetadata;
    uri: string;
    totalMinted: "0";

} & DeferredTokenIntentWithSignature;


export type ChannelTokenWithUserBalance = ChannelToken & {
    balance: string;
}

export const isTokenIntent = (arg: ChannelToken | ChannelTokenIntent | ChannelTokenV1): arg is ChannelTokenIntent => {
    return (arg as ChannelTokenIntent).tokenIntent !== undefined;
}

export const isTokenV2Onchain = (arg: ChannelToken | ChannelTokenIntent | ChannelTokenV1) => {
    return (arg as ChannelToken).sponsor !== undefined;
}

export const isTokenV1Onchain = (arg: ChannelToken | ChannelTokenIntent | ChannelTokenV1) => {
    return (arg as ChannelTokenV1).metadata.type === "uplink-v1";
}

export const isTokenAnimated = (arg: ChannelToken | ChannelTokenIntent | ChannelTokenV1) => {
    return arg.metadata.animation !== ''
}

export const doesChannelHaveFees = (channel: Channel) => {
    return channel.fees !== null;
}

export const isInfiniteChannel = (channel: Channel) => {
    return channel.transportLayer.type === "infinite";
}

export const isFiniteChannel = (channel: Channel) => {
    return channel.transportLayer.type === "finite";
}